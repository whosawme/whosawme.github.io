<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Expanding Node Tree with Collapse Feature</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; touch-action: none; }
        svg { width: 100vw; height: 100vh; }
        .node { cursor: pointer; }
    </style>
</head>
<body>
    <svg id="tree"></svg>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
        const svg = document.getElementById('tree');
        const nodeRadius = 20;
        let nodeId = 0;
        const colors = ['#4CAF50', '#2196F3', '#FFC107', '#E91E63', '#9C27B0', '#FF5722'];
        let isDragging = false;
        let startX, startY, activeNode, activeNodeX, activeNodeY, activeNodeGeneration;
        const allNodes = [];
        let lastTapTime = 0;
        let lastTappedNode = null;

        function createNode(x, y, parentX, parentY, generation, parent) {
            nodeId++;
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'node');
            group.setAttribute('id', `node-${nodeId}`);

            let line;
            if (parentX !== undefined && parentY !== undefined) {
                line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', parentX);
                line.setAttribute('y1', parentY);
                line.setAttribute('x2', x);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', 'white');
                svg.appendChild(line);

                gsap.from(line, {
                    attr: { x2: parentX, y2: parentY },
                    duration: 0.5,
                    ease: 'power2.out'
                });
            }

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', nodeRadius);
            circle.setAttribute('fill', colors[generation % colors.length]);

            group.appendChild(circle);
            svg.appendChild(group);

            gsap.from(circle, {
                attr: { r: 0 },
                duration: 0.5,
                ease: 'back.out(1.7)'
            });

            const nodeData = { group, circle, line, x, y, generation, children: [], parent, isCollapsed: false };
            allNodes.push(nodeData);

            return nodeData;
        }

        function toggleCollapse(nodeData) {
            nodeData.isCollapsed = !nodeData.isCollapsed;
            if (nodeData.isCollapsed) {
                collapseNode(nodeData);
            } else {
                expandNode(nodeData);
            }
        }

        function collapseNode(nodeData) {
            nodeData.children.forEach(child => {
                gsap.to(child.circle, { attr: { r: 0 }, duration: 0.3 });
                gsap.to(child.line, { opacity: 0, duration: 0.3 });
                child.group.style.pointerEvents = 'none';
                collapseNode(child);
            });
        }

        function expandNode(nodeData) {
            nodeData.children.forEach(child => {
                gsap.to(child.circle, { attr: { r: nodeRadius }, duration: 0.3 });
                gsap.to(child.line, { opacity: 1, duration: 0.3 });
                child.group.style.pointerEvents = 'auto';
                if (!child.isCollapsed) {
                    expandNode(child);
                }
            });
        }

        function handleStart(event) {
            event.preventDefault();
            const clientX = event.clientX || event.touches[0].clientX;
            const clientY = event.clientY || event.touches[0].clientY;
            startX = clientX;
            startY = clientY;
            const element = document.elementFromPoint(clientX, clientY);
            if (element && element.parentNode.classList.contains('node')) {
                activeNode = getNodeDataFromElement(element.parentNode);
                activeNodeX = activeNode.x;
                activeNodeY = activeNode.y;
                activeNodeGeneration = activeNode.generation;
                
                // Visual feedback
                gsap.to(activeNode.circle, { 
                    attr: { r: nodeRadius * 1.2 }, 
                    duration: 0.2, 
                    ease: 'power2.out' 
                });

                // Check for double tap
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTapTime;
                if (tapLength < 300 && tapLength > 0 && lastTappedNode === activeNode) {
                    toggleCollapse(activeNode);
                }
                lastTapTime = currentTime;
                lastTappedNode = activeNode;
            }
        }

        function handleMove(event) {
            if (activeNode) {
                event.preventDefault();
                const clientX = event.clientX || event.touches[0].clientX;
                const clientY = event.clientY || event.touches[0].clientY;
                const dx = clientX - startX;
                const dy = clientY - startY;
                if (Math.sqrt(dx * dx + dy * dy) > 20) {  // Minimum drag distance
                    isDragging = true;
                    const angle = Math.atan2(dy, dx);
                    const distance = 100;
                    const newX = activeNodeX + Math.cos(angle) * distance;
                    const newY = activeNodeY + Math.sin(angle) * distance;
                    const newNode = createNode(newX, newY, activeNodeX, activeNodeY, activeNodeGeneration + 1, activeNode);
                    activeNode.children.push(newNode);
                    resetActiveNode();
                }
            }
        }

        function handleEnd(event) {
            if (activeNode && !isDragging) {
                // Reset node size if not dragged
                gsap.to(activeNode.circle, { 
                    attr: { r: nodeRadius }, 
                    duration: 0.2, 
                    ease: 'power2.out' 
                });
            }
            resetActiveNode();
        }

        function resetActiveNode() {
            isDragging = false;
            activeNode = null;
        }

        function getNodeDataFromElement(element) {
            const id = element.getAttribute('id');
            return allNodes.find(node => node.group.id === id);
        }

        // Event listeners for both mouse and touch events
        svg.addEventListener('mousedown', handleStart);
        svg.addEventListener('touchstart', handleStart);
        svg.addEventListener('mousemove', handleMove);
        svg.addEventListener('touchmove', handleMove);
        svg.addEventListener('mouseup', handleEnd);
        svg.addEventListener('touchend', handleEnd);

        // Create the root node
        const rootNode = createNode(window.innerWidth / 2, window.innerHeight / 2, undefined, undefined, 0, null);

        // Prevent default touch behaviors
        document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
    </script>
</body>
</html>